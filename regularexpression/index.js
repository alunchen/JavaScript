/*
 * @Author: your name
 * @Date: 2020-09-21 10:36:23
 * @LastEditTime: 2020-09-21 14:31:12
 * @LastEditors: Please set LastEditors
 * @Description: 正则表达式
 * @FilePath: \instance-deployd:\JavaScript\regularexpression\index.js
 */

/**
 * 创建正则表达式的方式
 */
// 1. 字面量
let re = /ab+c/;
// 2. RegExp对象的构造函数
let re1 = new RegExp("ab+c");

// 简单模式
let a = "Hi, do you know your abc's";
//console.log(/abc/.test(a))

// 使用特殊字符
let b = "abbbbbbbbbbc";
//console.log(/ab*c/.test(b))

/**
 * 断言(Assertions)
 * 表示一个匹配在某些条件下发生。断言包含先行断言、后行断言和条件表达式
 */

/**
 * 字符类(Character Classes)
 * 区别不同类型的字符, 例如区分字母和数字
 */

/**
 * 组合范围(Groups and Ranges)
 * 表示表达式字符的分组和范围
 */

/**
 * 量词
 * 表示匹配的字符或表达式的数量
 */

/**
 * Unicode 属性转义
 * 基于Unicode字符属性区分字符, 例如大写和小写字母、数字符号和标点
 */

/**
 * 正则表达式中的 特殊字符
 *      \   
 *      在非特殊字符之前的反斜杠表示下一个字符是特殊字符，不能按照字面理解。例如，
 *  前面没有 "\" 的 "b" 通常匹配小写字母 "b"，即字符会被作为字面理解，无论它出
 *  现在哪里。但如果前面加了 "\"，它将不再匹配任何字符，而是表示一个字符边界。在
 *  特殊字符之前的反斜杠表示下一个字符不是特殊字符，应该按照字面理解。详情请参阅
 *  下文中的 "转义（Escaping）" 部分。如果你想将字符串传递给 RegExp 构造函数，不
 *  要忘记在字符串字面量中反斜杠是转义字符。所以为了在模式中添加一个反斜杠，你需
 *  要在字符串字面量中转义它。/[a-z]\s/i 和 new RegExp("[a-z]\\s", "i") 创建了
 *  相同的正则表达式：一个用于搜索后面紧跟着空白字符（\s 可看后文）并且在 a-z 范
 *  围内的任意字符的表达式。为了通过字符串字面量给 RegExp 构造函数创建包含反斜杠
 *  的表达式，你需要在字符串级别和正则表达式级别都对它进行转义。例如 /[a-z]:\\/i 
 *  和 new RegExp("[a-z]:\\\\","i") 会创建相同的表达式，即匹配类似 "C:\" 字符串。
 */

/**
 * ( ^ )  
 * 匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。
 * 例如，/^A/ 并不会匹配 "an A" 中的 'A'，但是会匹配 "An E" 中的 'A'。
 * 当 '^' 作为第一个字符出现在一个字符集合模式时，它将会有不同的含义
 */
//console.log(/^A/.test('And Addd'))

/**
 * ( $ )
 * 匹配输入的结束。如果多行标志被设置为 true，那么也匹配换行符前的位置。
 * 例如，/t$/ 并不会匹配 "eater" 中的 't'，但是会匹配 "eat" 中的 't'。
 */
//console.log(/world$/.test('hello world'))

/**
 * ( * )
 * 匹配前面一个表达式 0次或多次，等价于{0, }
 */
// 例如，/bo*/ 会匹配 "A ghost boooooed" 中的 'booooo' 和 "A bird warbled" 中的 'b'，但是在 "A goat grunted" 中不会匹配任何内容。
//console.log(/abc*/.test('ab'))

/**
 * ( + )
 * 匹配前面一个表达式 1次或多次，等价于{1, }
 * 例如，/a+/ 会匹配 "candy" 中的 'a' 和 "caaaaaaandy" 中所有的 'a'，但是在 "cndy" 中不会匹配任何内容。
 */
//console.log(/ab+/.test('abbb'))

/**
 * ( ? )
 * 匹配前面一个表达式 0 次或者 1 次。等价于 {0,1}。
 * 例如，/e?le?/ 匹配 "angel" 中的 'el'、"angle" 中的 'le' 以及 "oslo' 中的 'l'。
 *      如果紧跟在任何量词 *、 +、? 或 {} 的后面，将会使量词变为非贪婪（匹配尽量少的字符），
 * 和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反。例如，对 "123abc" 使用 /\d+/ 将会匹
 * 配 "123"，而使用 /\d+?/ 则只会匹配到 "1"。
 */

/**
 * ( . )
 * （小数点）默认匹配除换行符之外的任何单个字符。
 * 例如，/.n/ 将会匹配 "nay, an apple is on the tree" 中的 'an' 和 'on'，但是不会匹配 'nay'。
 * 如果 s ("dotAll") 标志位被设为 true，它也会匹配换行符。
 */

/**
 * (x)  匹配 'x' 并且记住匹配项。其中括号被称为捕获括号。
 *      模式 /(foo) (bar) \1 \2/ 中的 '(foo)' 和 '(bar)' 匹配并记住字符串 "foo bar foo bar" 中
 * 前两个单词。模式中的 \1 和 \2 表示第一个和第二个被捕获括号匹配的子字符串，即 foo 和 bar，
 * 匹配了原字符串中的后两个单词。注意 \1、\2、...、\n 是用在正则表达式的匹配环节，详情可以参
 * 阅后文的 \n 条目。而在正则表达式的替换环节，则要使用像 $1、$2、...、$n 这样的语法，例如，
 * 'bar foo'.replace(/(...) (...)/, '$2 $1')。$& 表示整个用于匹配的原字符串。
 */


/**
 * (?:x)  匹配 'x' 但是不记住匹配项。这种括号叫作非捕获括号
 *      使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 
 * /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2} 将只应用于 'foo' 的
 * 最后一个字符 'o'。如果使用非捕获括号，则 {1,2} 会应用于整个 'foo' 单词
 */


/**
 * x(?=y)   匹配'x'仅仅当'x'后面跟着'y',这种叫做先行断言。
 *      例如，/Jack(?=Sprat)/会匹配到'Jack'仅当它后面跟着'Sprat'。
 * /Jack(?=Sprat|Frost)/匹配‘Jack’仅当它后面跟着'Sprat'或者是‘Frost’。
 * 但是‘Sprat’和‘Frost’都不是匹配结果的一部分。
 */


/**
 * (?<=y)x  匹配'x'仅当'x'前面是'y'.这种叫做后行断言。
 *      例如，/(?<=Jack)Sprat/会匹配到' Sprat '仅仅当它前面是' Jack '。
 * /(?<=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是'Jack'或者是‘Tom’。
 * 但是‘Jack’和‘Tom’都不是匹配结果的一部分。
 */


/**
 * x(?!y)   仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找。
 *      例如，仅仅当这个数字后面没有跟小数点的时候，/\d+(?!\.)/ 匹配一
 * 个数字。正则表达式/\d+(?!\.)/.exec("3.141")匹配‘141’而不是‘3.141’
 */
