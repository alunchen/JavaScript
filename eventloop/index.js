/**
 * 事件循环
 *    浏览器是一个多进程多线程的应用程序
 *      浏览器进程、网络进程、渲染进程等等
 */

/**
 * 浏览器进程
 *    主要负责界面显示、用户交互、子进程管理等。浏览器进程内部会启动多个线程处理不同的任务
 */



/**
 * 网络进程
 *    负责加载网络资源。网络进程内部会启动多个线程处理不同的网络任务
 */



/**
 * 渲染进程
 *    渲染进程启动后，会开启一个 **渲染主线程** ，主线程负责执行HTML、CSS、JS代码。默认情况下，浏览器会为每一个
 * 标签页开启一个新的渲染进程。以保证不同的标签页之间互不影响
 */

/**
 * 渲染主线程是浏览器中最繁忙的线程，需要它处理的任务包括但不限于：
 *    解析HTML
 *    解析CSS
 *    计算样式
 *    布局
 *    处理图层
 *    每秒把页面画60次    FPS 
 *    执行全局JS代码
 *    执行事件处理函数
 *    执行计时器的回调函数
 *    ......
 */

// 为什么渲染进程不适用多个线程来处理事件？




/**
 * 何为异步
 *    代码在执行过程中，会遇到一些无法立即处理的任务，比如：
 *      计时完成后需要执行的任务 -- setTimeout、setInterval
 *      网络通信完成后需要执行的任务  -- XHR、Fetch
 *      用户操作后需要执行的任务  -- addEventListener
 * 
 *    如果让渲染主线程等待这些任务的时机达到，就会导致主线程长期处于 阻塞 状态，从而导致浏览器 卡死
 * 
 * 
 * 
 *  如何理解JS的 异步
 *      JS是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个，而渲染主线程
 *  承担这诸多的工作，渲染页面、执行JS都在其中运行。如果使用同步的方式，就极有可能导致主线程产生阻塞，
 *  从而导致消息队列中的很多其他任务无法得到执行，这样一来，一方面会导致繁忙的主线程白白的消耗时间，另
 *  一方面导致页面无法及时更新，给用户造成卡死的现象
 *      所以浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将
 *  任务交给其他线程去处理，自身立即结束任务的执行，转而执行后续的代码。当其他线程完成时，将事先传递的回调
 *  函数包装成任务，加入到消息队列的末尾排队，等待主线程调度执行
 *    在这种异步模式下，浏览器永不阻塞，从而最大限定的保证了单线程的流程运行
 * 
 * 
 * 
 * 
 *  JS为何会阻碍渲染
 *      JS和渲染都在浏览器的渲染主线程上进行
 * 
 * 
 *  任务有优先级吗
 *      任务没有优先级，在消息队列中先进先出 
 * 
 *  但消息队列是有优先级的
 * 
 *      根据W3C的最新解释：
 *        ** 每个任务都有一个任务类型，同一个类型的任务必须在一个队列，不同类型的任务可以分属于不同的队列
 *        在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行
 * 
 *        ** 浏览器必须准备号一个微队列，微队列中的任务优先所有任务执行
 * 
 * 
 * 
 *      在目前chrome的实现中，至少包含了下面的队列
 *        ** 延时队列：用于存放计时器到达后的回调任务，优先级【中】
 *        ** 交互队列：用于存放用户操作后产生的事件处理任务，优先级【高】
 *        ** 微队列：用户存放需要最快执行的任务，优先级【最高】   Promise、MutationObserver
 *            // 立即把一个函数放到微队列
 *            Promise.resolve().then(函数)
 */


